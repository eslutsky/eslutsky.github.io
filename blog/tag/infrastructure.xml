<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oVirt</title>
  <subtitle>Tag: Infrastructure</subtitle>
  <id>http://ovirt.org/blog/</id>
  <link href="http://ovirt.org/blog/"/>
  <link href="http://ovirt.org/blog/tag/infrastructure.xml" rel="self"/>
  <updated>2019-05-27T15:35:00+00:00</updated>
  <author>
    <name/>
  </author>
  <entry>
    <title>oVirt System Tests to the Rescue!&amp;mdash;How to Run End-to-End oVirt Tests on Your Patch</title>
    <link rel="alternate" href="http://ovirt.org/blog/2017/01/ovirt-system-tests-to-the-rescue.html"/>
    <id>http://ovirt.org/blog/2017/01/ovirt-system-tests-to-the-rescue.html</id>
    <published>2017-01-03T10:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Eyal Edri</name>
    </author>
    <content type="html">&lt;p&gt;Today, when an oVirt developer pushes a patch to review on oVirt Gerrit, various validations are triggered in CI via the &lt;a href="http://ovirt-infra-docs.readthedocs.io/en/latest/CI/Build_and_test_standards.html"&gt;'check-patch'&lt;/a&gt; job, as defined by the project maintainers. Usually these jobs includes 'unit-tests', 'db tests', static analysis checks, and even an occasional 'functional test'. While it might seem that it covers alot and gives a good indication that the patch is good to be merged, unfortunately it is not always the case.&lt;/p&gt;

&lt;p&gt;The reason it's not enough lies in oVirt's complexity and the fact it's a Virtualization project, which means the only real way to know if your patch didn't break things is to install oVirt and try running a few basic commands, like 'adding host', 'adding vm', 'creating snapshots', and other tasks you can only do if you have a full oVirt system up and running. Here is where OST comes in!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="ovirt-system-tests"&gt;oVirt System Tests&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://ovirt-system-tests.readthedocs.io"&gt;oVirt system tests&lt;/a&gt; is a testing framework written in Python, using 'python-nose' and oVirt Python SDK and runs on auto-generated VMs created by &lt;a href="http://lago.readthedocs.io"&gt;Lago&lt;/a&gt;. It is used by the oVirt CI to run post merge end-to-end testing that runs on a fully deployed oVirt environment and has been proven to detect multiple
regressions so far on merged commits from oVirt projects.&lt;/p&gt;

&lt;h2 id="the-current-status-and-why-it-is-never-enough"&gt;The Current Status (And Why it is Never Enough)&lt;/h2&gt;

&lt;p&gt;So you may ask yourself: if we have OST running after (almost) every merged commit, where is the problem? You might have guessed the answer which is already in the question–it's only 'AFTER', which means it's detected too late in the development cycle. The result of such breakage in CI means that any other developer using the same branch will now be blocked from working/verifying his patch because existing HEAD is broken, and usually it takes some time to either revert the offending patch or send a fix (and that's after the relevant people were found and started debugging the issue). On some occasions in the past, it even took a few days to see a fix merged. During that time, developers and testers were blocked, not an ideal status.&lt;/p&gt;

&lt;p&gt;Luckily, we now have a super easy way to avoid this!&lt;/p&gt;

&lt;h2 id="running-ost-on-open-patches-pre-merge"&gt;Running OST on Open Patches (Pre Merge)&lt;/h2&gt;

&lt;p&gt;I know you can't wait to hear about how to run OST on your patch, so I'll just jump into the TL;DR version, here is how you do it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Build RPMs from your open patch(es)&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;Building RPMs today from any open oVirt patch is simple as just
  asking for it.. :)&lt;br /&gt;
  The new 'build-on-demand' option from oVirt Standard CI allows
  you to just type &lt;strong&gt;ci please build&lt;/strong&gt; in a comment on your patch
  and a new build will be triggered on the project 'build-on-demand' jobs.&lt;br /&gt;
  Once the 'build-on-demand' job finished building, write down the job URL,
  for e.g: &lt;a href="http://jenkins.ovirt.org/job/vdsm_master_build-artifacts-on-demand-el7-x86_64/9/"&gt;vdsm-master-build-on-demand&lt;/a&gt;.
  (btw, you can do this for as many oVirt projects you want and have a list of URLs).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Run the manual OST job with your custom RPMs&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;Now that you have your custom RPMs ready, your JUST a click away from running OST
  on them.&lt;br /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Login to &lt;a href="http://jenkins.ovirt.org"&gt;Jenkins&lt;/a&gt; (make sure you have 'dev role' permissions, if not open a ticket to infra)&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Go to the &lt;a href="http://jenkins.ovirt.org/job/ovirt-system-tests_manual/"&gt;OST Manual job&lt;/a&gt; for your relevant version (usually master).&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Click on 'build with parameters' menu ( on the left side )&lt;/li&gt;
      &lt;li&gt;Now add all the URLs you have with the custom RPMs ( one per line ),for e.g &lt;a href="http://jenkins.ovirt.org/job/vdsm_master_build-artifacts-on-demand-el7-x86_64/9/"&gt;vdsm-build&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Click 'Build'&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Go get some coffee; Don't worry the job will send you an email once it is done ( on any status )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This info can also be found on the &lt;a href="http://ovirt-system-tests.readthedocs.io/en/latest/CI/developers_info/"&gt;official OST documentation page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For more info or questions, please send email to infra@ovirt.org or lago-devel@ovirt.org if it is a lago-related question.&lt;/p&gt;

&lt;p&gt;Happy testing!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>CI Please Build&amp;mdash;How to build your oVirt project on-demand</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/12/ci-please-build.html"/>
    <id>http://ovirt.org/blog/2016/12/ci-please-build.html</id>
    <published>2016-12-20T10:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Eyal Edri</name>
    </author>
    <content type="html">&lt;p&gt;All projects in oVirt CI are built today post merge, using the 'build-artifacts' stage from &lt;a href="http://ovirt-infra-docs.readthedocs.io/en/latest/CI/Build_and_test_standards.html"&gt;oVirt's CI standards&lt;/a&gt;.
This ensures that all oVirt projects are built and deployed to oVirt repositories and can be consumed by CI jobs, developers or oVirt users.&lt;/p&gt;

&lt;p&gt;However, on some occasions a developer might need to build his project from an open patch.
Developers need this capability in order to to examine the effects of their changes on a full oVirt installation before merging those changes.
On some cases developers may even want to hand over packages based on un-merged patches to the QE team to verify that a given change will fix some complex issue or to preview a new feature on its early stages of development.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="the-current-build-option"&gt;The Current Build Option&lt;/h2&gt;

&lt;p&gt;Until now, to build rpms from a patch, a developer needed to use a custom &lt;a href="http://jenkins.ovirt.org/job/ovirt-engine_master_build-artifacts-el7-x86_64_build_from_patch/"&gt;Jenkins job&lt;/a&gt;, which was only available to ovirt-engine and only for master branch. Another option was to try and build it locally using standard CI 'mock runner.sh' script which will use the same configuration
as in CI. For full documentation on how to use 'mock-runner', checkout the &lt;a href="http://infra-docs.readthedocs.io/en/latest/CI/Build_and_test_standards.html#testing-the-scripts-locally"&gt;Standard CI&lt;/a&gt; page.&lt;/p&gt;

&lt;h2 id="the-new-build-option"&gt;The New Build Option&lt;/h2&gt;

&lt;p&gt;To ease and simplify the build from patch option, the oVirt infra team added a new feature to the &lt;a href="http://ovirt-infra-docs.readthedocs.io/en/latest/CI/Build_and_test_standards.html"&gt;oVirt's CI standards framework&lt;/a&gt; called 'build on demand'.&lt;/p&gt;

&lt;p&gt;It allows any oVirt developer to trigger a build from any open patch just by adding the comment 'ci please build' on the patch in Gerrit.
It will then trigger a 'build-artifacts-on-demand' job on jenkins which will build rpms from the patch, but not publish them to any repo.&lt;/p&gt;

&lt;h2 id="how-do-i-enable-it-for-my-ovirt-project-"&gt;How Do I Enable It For My oVirt Project ?&lt;/h2&gt;

&lt;p&gt;Enabling the 'build-on-demand' feature to an oVirt project is simple as adding a single line to the project standard yaml file, just add the following line to your 'build-artifacts' section, under 'jobs':&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;  - '{project}_{version}_{stage}-on-demand-{distro}-{arch}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For a full example on how to send a patch for enabling it,
Checkout an example &lt;a href="https://gerrit.ovirt.org/#/c/68759/"&gt;Patch&lt;/a&gt; which adds on-demand builds to four different projects.&lt;/p&gt;

&lt;h2 id="what-else-can-i-do-with-it--hint-ost"&gt;What Else Can I Do With It ? (Hint: OST)&lt;/h2&gt;

&lt;p&gt;Maybe the most interesting and valuable thing you can do with the new feature, is to run the oVirt system tests suit on
the open patch (something that was possible only post merge until today, or required complex actions to do it manually).&lt;/p&gt;

&lt;p&gt;Running the OST suite with your newly created RPMs requires also just one line of code, here's how you do it:&lt;/p&gt;

&lt;p&gt;After the job you triggered finished running in Jenkins, use the Jenkins build URL you got (&lt;a href="http://jenkins.ovirt.org/job/vdsm_master_build-artifacts-on-demand-el7-x86_64/1/artifact/exported-artifacts/"&gt;Example&lt;/a&gt;)
as a parameter to to run OST on your laptop.
From the OST root dir, run the following to run basic master suite for e.g:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;./run_suite.sh -s http://jenkins.ovirt.org/job/vdsm_master_build-artifacts-on-demand-el7-x86_64/1/artifact/exported-artifacts/ basic_suite_master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more info and help on using this new feature, feel free to come and ask us on infra@ovirt.org.&lt;br /&gt;
For more info on oVirt system tests, checkout the &lt;a href="http://ovirt-system-tests.readthedocs.io"&gt;Project Documentation Page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Happy Building!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>The Need for Speed&amp;mdash;Coming Changes in oVirt's CI Standards</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/12/the-need-for-speed.html"/>
    <id>http://ovirt.org/blog/2016/12/the-need-for-speed.html</id>
    <published>2016-12-08T15:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Barak Korren</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://ovirt-infra-docs.readthedocs.io/en/latest/CI/Build_and_test_standards.html"&gt;oVirt's CI standards&lt;/a&gt; have been in use for a while in most oVirt projects and have largely been a success.&lt;/p&gt;

&lt;p&gt;These standards have put the control of what the CI system does in the hands of the developers without them
having to learn about &lt;a href="https://jenkins.io/"&gt;Jenkins&lt;/a&gt; and the &lt;a href="http://docs.openstack.org/infra/jenkins-job-builder/index.html"&gt;tooling around it&lt;/a&gt;. The way the standards were implemented, with the &lt;a href="https://gerrit.ovirt.org/gitweb?p=jenkins.git;a=blob;f=mock_configs/mock_runner.sh"&gt;&lt;code&gt;mock_runner.sh&lt;/code&gt; script&lt;/a&gt;, also enabled developers to easily emulate the CI system on their own machines to debug and diagnose issues.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;From the oVirt infra team's point of view, the CI standards have removed the need to constantly maintain build dependencies on the Jenkins slaves and also eliminated most of the situations where jobs running on the same slave influenced one another.&lt;/p&gt;

&lt;p&gt;The CI standards implementation we have has one shortcoming, it is not particularity fast.&lt;/p&gt;

&lt;p&gt;We started seriously looking at this after one of the VDSM maintainers &lt;a href="https://lists.ovirt.org/pipermail/devel/2016-December/014386.html"&gt;reported&lt;/a&gt; that the &lt;code&gt;check_patch&lt;/code&gt; jobs for his project are running for far too long a time. In the end it turned out that a major reason for the delay was in the way the &lt;a href="https://gerrit.ovirt.org/#/c/67799/"&gt;tests themselves worked&lt;/a&gt;, but still, we looked at &lt;code&gt;mock_runner.sh&lt;/code&gt; and managed to speed it up quite a bit.&lt;/p&gt;

&lt;h2 id="what-did-we-change"&gt;What Did We Change?&lt;/h2&gt;

&lt;p&gt;Most of the time &lt;code&gt;mock_runner.sh&lt;/code&gt; spends when it isn't actually running the user's CI script, is spent setting up the &lt;a href="https://github.com/rpm-software-management/mock"&gt;&lt;code&gt;mock&lt;/code&gt;&lt;/a&gt; environment. It turns out that despite mock being able to cache mock environments, we were aggressively erasing the cache after each job invocation leading to the same environment having to be rebuilt.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gerrit.ovirt.org/#/c/67795/"&gt;The first change we implemented&lt;/a&gt; was simply to stop deleting the whole cache and instead only delete files that are older then two days.&lt;/p&gt;

&lt;p&gt;The CI standard allows developers to specify additional packages that would be available inside the mock environment. With the way &lt;code&gt;mock_runner.sh&lt;/code&gt; was implemented, those packages were installed in a way that prevented them from being included in the mock cache. This means they were newly installed every time a job was running.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://gerrit.ovirt.org/#/c/67801/"&gt;The second change we implemented&lt;/a&gt; was therefore to ensure those packages were saved to the mock cache as well.&lt;/p&gt;

&lt;h2 id="what-this-means-for-ovirt-developers"&gt;What This Means for oVirt Developers&lt;/h2&gt;

&lt;p&gt;The most noticeable aspect of the changes we've implemented (Besides the shorter job run times), is that while previously the mock environment was freshly installed with the latest packages for each CI job, now most jobs will use a cached mock environment that can be up to two days old.&lt;/p&gt;

&lt;p&gt;Most developers will probably not notice the change, but sometimes the most recent package are needed at all times. In that case there are two thinks developers can do:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Specify the exact required version of the package in the CI standard &lt;code&gt;*.packages&lt;/code&gt; file.&lt;/li&gt;
  &lt;li&gt;Install the package explicitly with a &lt;code&gt;yum&lt;/code&gt; or a &lt;code&gt;dnf&lt;/code&gt; command from the CI standard script.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="bottom-line-how-much-faster-is-it"&gt;Bottom Line, How Much Faster Is It?&lt;/h2&gt;

&lt;p&gt;In our tests, by using the changes above, we managed to shorten the time to setup the mock environment from 2.5-3 minutes to around 20 seconds! That is a worthwhile change indeed.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This blog post originally appeared on &lt;a href="https://ifireball.wordpress.com/2016/12/07/the-need-for-speed-coming-changes-in-ovirts-ci-standards/"&gt;Barak Korren's blog&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Manage Your Hosted Engine Hosts Deployment Via Engine</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/07/Manage-Your-Hosted-Engine-Hosts-Deployment.html"/>
    <id>http://ovirt.org/blog/2016/07/Manage-Your-Hosted-Engine-Hosts-Deployment.html</id>
    <published>2016-07-27T19:14:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Roy Golan</name>
    </author>
    <content type="html">&lt;p&gt;Hosted engine has seen a lot of progress and evolution, and today it is is the &lt;em&gt;de facto&lt;/em&gt; recommended way to to deploy your oVirt Engine. But since that special Hosted Engine High Availability (HA) cluster itself needs management, we worked on making that be managed by the hosted engine itself, too.&lt;/p&gt;

&lt;p&gt;Recent oVirt versions made it lot more easier to deploy hosted-engine, first by introducing the appliance and cloud-init customization
phase, next with VM configuration being stored on the shared storage and making the VM itself manageable from the UI itself. A few more under-the-hood changes resulted in storing event the cluster configuration on the shared storage itself, opening the door to making the expanding of the HA-cluster even easier, as all answers and configuration were now already available.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="whats-new-in-40"&gt;What's New in 4.0&lt;/h2&gt;

&lt;p&gt;What this version is adding is the capability to add and remove more HA hosts using the engine itself, instead of going over machine by machine and running the cli utility, &lt;code&gt;hosted-engine --deploy&lt;/code&gt;, to get you up and running. Since oVirt has a well-established host installation subsystem, otopi, which installs and configures with host by the engine, we just needed to plug in the part to install and configure the HA services (ovirt-ha-agent and broker).&lt;/p&gt;

&lt;p&gt;The obvious advantages of expanding the cluster from the engine is that you gain all the advantages of using the UI or REST API. It's easy to use, scriptable if you want, and more importantly, it's a single place you need to be instead of doing round-trips to your machine (over ssh of course :)) for your provisioning operations. Technically, it also makes the process go through the engine, which enforces the engine into being the single source of configuration (instead of scattered configuration across hosts).&lt;/p&gt;

&lt;h2 id="how-does-it-work"&gt;How Does It Work?&lt;/h2&gt;

&lt;p&gt;First things first, in &lt;code&gt;bootstrap mode&lt;/code&gt; we don't have an engine VM yet. The first host is being installed using &lt;code&gt;hosted-engine --deploy&lt;/code&gt; and we end up with with the VM up and running, and with all configuration saved on the shared storage (by default named &lt;strong&gt;hosted_storage&lt;/strong&gt;). Next:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;After adding the master data domain and activating the DC, the VM is imported with the storage configuration into the engine. Our HA cluster is self aware!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add a host, choose the &lt;strong&gt;Hosted-Engine&lt;/strong&gt; side tab and click &lt;code&gt;Deploy&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The engine will go download the configuration disk from &lt;strong&gt;hosted_storage&lt;/strong&gt;. The disk has a special description by which we identify the disk. The hosted-engine.conf is extracted from that disk. It will be used as the configuration of the &lt;code&gt;ovirt-ha-agent&lt;/code&gt; service to connected to the storage, participate in &lt;code&gt;sanlock&lt;/code&gt; space and its unique &lt;code&gt;host_id&lt;/code&gt;. It's important to note that the &lt;code&gt;host_id&lt;/code&gt; is maintained by &lt;strong&gt;ovirt-engine&lt;/strong&gt;, in the DB, so its guaranteed to be unique and will not collide with the rest of the host in the datacenter, including hosts which are regular, non-HE hosts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The engine invokes the host-install process and passes a special section (called deploy unit) with the configuration. The HE package is being installed and &lt;code&gt;hosted-engine.conf&lt;/code&gt; is written into &lt;code&gt;/etc/ovirt-hosted-engine-ha/hosted-engine.conf&lt;/code&gt;, and the services are started.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Next, the services boots up and performs the regular steps to properly join the cluster—connect to the storage and monitor it, download the VM OVF and prepare a vm.conf out of it, monitor its resources and crunch a score out of it so the host will be accepted as a cluster member.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At the end, VDSM will report the &lt;code&gt;ha_score&lt;/code&gt; of that host and it will be capable of running the HE VM.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img alt="alt text" title="Sequence diagram of HE hosts management" width="960" height="720" src="/images/wiki/managing-hosted-engine-hosts-via-engine.png?1560777612" /&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Subclusters in oVirt 4.0 - Label-Based VM to Host Affinity</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/07/affinity-labels.html"/>
    <id>http://ovirt.org/blog/2016/07/affinity-labels.html</id>
    <published>2016-07-25T15:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Martin Sivak</name>
    </author>
    <content type="html">&lt;p&gt;Before I start discussing the feature itself I have to explain a bit about the use cases that we were trying to solve.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Let us imagine you have a special piece of software with a node-licensing model that only cares about physical machines when counting the number of licenses needed. This specifically allows you to run that software in virtual machines, but you need to control the physical host on which the VMs are running.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The other case is basically related to hardware capabilities. Some NICs might be faster than others and you want to place all high traffic VMs on hosts that have them. Or a special custom device is needed and VMs that need it won’t run on a host that does not have it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Both cases follow the same basic scenario: There is a small subset of VMs that need a special capability (license, device), but there are not enough of them to fully utilize a separate cluster. To achieve efficient utilization of your cluster, you need to add many common VMs with no special needs and some hosts to handle the full load. But… how do you keep the special VMs from migrating to the hosts without the special capabilities?&lt;/p&gt;

&lt;p&gt;We already had &lt;a href="/documentation/admin-guide/administration-guide/#affinity-groups"&gt;VM to host pinning&lt;/a&gt; that allowed limiting VM placement to &lt;a href="/develop/release-management/features/vmpinningtomultiplehosts/"&gt;single or multiple hosts&lt;/a&gt;, but with no migration enabled for that VM. Our team also just implemented a new feature that allows you to define pinning and still keep migration enabled. Affinity labels allow you to take a subset of hosts and attach a label to them. Any VM with the same affinity label will be then constrained to the labeled hosts. Standard VMs with no labels won’t notice anything and will still happily run anywhere according to the normal oVirt scheduling rules.&lt;/p&gt;

&lt;p&gt;Now the bad news, there is no edit enabled user interface for now and all changes need to be done using the oVirt engine REST API. We have a development version of read only view for host and VM to affinity label assignments for getting a quick overview of the configuration and we plan to have full fledged UI in the future.&lt;/p&gt;

&lt;p&gt;The rest of this post will show you how to implement an example setup with three groups of hosts: webserver, storage and applications:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Example affinity groups layout" width="300" height="370" src="/images/affinity-label-example-diagram.png?1560777613" /&gt;&lt;/p&gt;

&lt;p&gt;I will be using my local server &lt;code&gt;localhost:8080&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;jq&lt;/code&gt;, and a specially crafted shell alias to avoid repeating the login and content type parameters in every example call. Tweak the admin@internal user and letmein password to match the user you will be using. Please note that if you are not using the admin account then you need to make sure the user has the &lt;em&gt;TagManager&lt;/em&gt; permissions.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;alias cengine='curl -s -u admin@internal:letmein -H "Content-Type: application/json" -H "Accept: application/json"'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="creating-and-updating-a-label"&gt;Creating and Updating a Label&lt;/h2&gt;

&lt;p&gt;Creating a new affinity label is a straightforward operation, just send a POST request to the right endpoint while saving the ID to a variable:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ STORAGELABEL=$(cengine -f -X POST -d '{"name": "test"}' http://localhost:8080/ovirt-engine/api/affinitylabels | jq -r '.id'); echo $STORAGELABEL

cc8bcf08-bc78-40e9-a01a-38a0fe99ea26
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Operations for listing all labels and updating a label’s name are also supported, of course:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;cengine -f http://localhost:8080/ovirt-engine/api/affinitylabels | jq -r '.affinity_label[] | {id, name}'

{
  "id": "cc8bcf08-bc78-40e9-a01a-38a0fe99ea26",
  "name": "test"
}

cengine -X PUT -d '{"name": "storage_subcluster"}' http://localhost:8080/ovirt-engine/api/affinitylabels/$STORAGELABEL | jq -r '{id, name}'

{
  "id": "cc8bcf08-bc78-40e9-a01a-38a0fe99ea26",
  "name": "storage_subcluster"
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="attaching-hosts-and-vms-to-a-label"&gt;Attaching Hosts and VMs to a Label&lt;/h2&gt;

&lt;p&gt;Affinity labels reference all labeled objects using their id, although the API accepts the full object representation. It will ignore all fields except id, though. There are two ways to manipulate affinity label assignments to hosts and VMs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Posting the host or VM to the proper affinity label subcollection&lt;/li&gt;
  &lt;li&gt;Posting the affinity label to the host’s or VM’s affinitylabels subcollection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We need some VMs and Hosts for the following examples so create hosts red, green, and blue as well as some VMs: webserver, storage, application1, and application2.&lt;/p&gt;

&lt;p&gt;I will now show you how to express the following rules using the affinity labels:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Webserver VM should be allowed to run anywhere&lt;/li&gt;
  &lt;li&gt;Storage VM should be restricted to host red (special HBA card maybe?)&lt;/li&gt;
  &lt;li&gt;Application VMs should be restricted to hosts red and blue (as you have license for two physical nodes, for example)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will first attach the storage VM and the red host to the already created storage_subcluster affinity label:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ cengine -f -X POST -d "{\"id\": \"$REDHOSTID\"}" http://localhost:8080/ovirt-engine/api/affinitylabels/$STORAGELABEL/hosts | jq -r '.status'

complete

$ cengine -f -X POST -d "{\"id\": \"$STORAGEVMID\"}" http://localhost:8080/ovirt-engine/api/affinitylabels/$STORAGELABEL/vms | jq -r '.status'

complete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can create the application affinity group and attach the necessary hosts and VMs:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ APPLABEL=$(cengine -f -X POST -d '{"name": "app_subcluster"}' http://localhost:8080/ovirt-engine/api/affinitylabels | jq -r '.id'); echo $APPLABEL

d7d91849-262d-4274-bb47-3ad711566fc7

$ for host in $REDHOSTID $BLUEHOSTID; do cengine -f -X POST -d "{\"id\": \"$APPLABEL\"}" http://localhost:8080/ovirt-engine/api/hosts/$host/affinitylabels | jq -r '.status'; done

completed
completed

$ for vm in $APP1VMID $APP2VMID; do cengine -f -X POST -d "{\"id\": \"$APPLABEL\"}" http://localhost:8080/ovirt-engine/api/vms/$vm/affinitylabels | jq -r '.status'; done

completed
completed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="deleting-labels-or-assignments"&gt;Deleting Labels or Assignments&lt;/h2&gt;

&lt;p&gt;That concludes the setup. You can use a standard REST DELETE call in case you need to remove a label to host assignment (just replace hosts with VMs to make it work for label to VM assignments):&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;cengine -f -X DELETE http://localhost:8080/ovirt-engine/api/hosts/$hostid/affinitylabels/$labelid | jq -r '.status'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;cengine -f -X DELETE http://localhost:8080/ovirt-engine/api/affinitylabels/$labelid/hosts/$hostid | jq -r '.status'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="the-result"&gt;The Result&lt;/h2&gt;

&lt;p&gt;The situation now is as described at the beginning, and will be obeyed during VM startups and VM migrations.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ cengine -f http://localhost:8080/ovirt-engine/api/affinitylabels | jq -r '.affinity_label[] | {id, name, vms, hosts}'

{
  "id": "cc8bcf08-bc78-40e9-a01a-38a0fe99ea26",
  "name": "storage_subcluster",
  "vms": {
    "vm": [
      {“id": "bd6e32cd-1df5-4c5c-a44e-371371e44168"}
    ]
  },
  "hosts": {
    "host": [
      {"id": "4d711089-a3e3-45b7-935a-dc66c4c4ccef"}
    ]
  }
}
{
  "id": "d7d91849-262d-4274-bb47-3ad711566fc7",
  "name": "app_subcluster",
  "vms": {
    "vm": [
      {"id": "a98d58ee-73e4-40be-95f8-bf360e646473"},
      {"id": "7506d8f9-7b40-4ee2-85be-6a7b02024729"}
    ]
  },
  "hosts": {
    "host": [
      {"id": "e2715dfc-5e21-45c1-9e9e-c2d316dc51dd"},
      {"id": "4d711089-a3e3-45b7-935a-dc66c4c4ccef"}
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I hope this new feature will be useful for you, and should you have any questions, do not hesitate to ask on &lt;a href="&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#117;&amp;#115;&amp;#101;&amp;#114;&amp;#115;&amp;#064;&amp;#111;&amp;#118;&amp;#105;&amp;#114;&amp;#116;&amp;#046;&amp;#111;&amp;#114;&amp;#103;"&gt;&amp;#117;&amp;#115;&amp;#101;&amp;#114;&amp;#115;&amp;#064;&amp;#111;&amp;#118;&amp;#105;&amp;#114;&amp;#116;&amp;#046;&amp;#111;&amp;#114;&amp;#103;&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Editable Field Annotations Consolidation</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/07/annotations-consolidation-blog.html"/>
    <id>http://ovirt.org/blog/2016/07/annotations-consolidation-blog.html</id>
    <published>2016-07-18T16:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Phillip Bailey</name>
    </author>
    <content type="html">&lt;p&gt;Robust functionality with minimum verbosity and complexity is a goal for which developers often strive.&lt;/p&gt;

&lt;p&gt;To that end, we have refactored the annotations used to indicate which fields are editable for hosts and virtual machines.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="the-problem"&gt;The Problem&lt;/h2&gt;

&lt;p&gt;Prior to the change, the following annotations were used:&lt;/p&gt;

&lt;p&gt;For VMs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;EditableField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableHostedEngineField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableOnVmStatusField&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For VM Templates:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;EditableField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableOnTemplate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For Hosts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;EditableField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableOnVdsStatus&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This lead to fields with an overabundance of individual annotations. For example, take the &lt;code&gt;memSizeMb&lt;/code&gt; field in the &lt;code&gt;VmBase&lt;/code&gt; class:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;@CopyOnNewVersion
@EditableOnVmStatusField(isHotsetAllowed = true)
@EditableOnTemplate
@EditableHostedEngineField
private int memSizeMb;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Logically, each of the Editable* annotations are communicating the same information: the circumstances under which a given field is editable. However, &lt;code&gt;EditableOnVmStatusField&lt;/code&gt; and &lt;code&gt;EditableOnHostedEngineField&lt;/code&gt; indicate conditions under which a VM entity can be edited, whereas &lt;code&gt;EditableOnTemplate&lt;/code&gt; indicates the entity type for which the field is editable (&lt;code&gt;VmTemplate&lt;/code&gt;). It is easy to see how this can be a bit confusing for someone reading through this code, especially if they are unfamiliar with it.&lt;/p&gt;

&lt;h2 id="the-solution"&gt;The Solution&lt;/h2&gt;

&lt;p&gt;In the first step of the refactor, new annotation names were created that indicate the entity type for which the annotated field is editable:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;EditableVmField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableVdsField&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditableVmTemplateField&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the second step, each of the conditions described by the old annotation names were turned into fields in the applicable annotation. For example, the &lt;code&gt;EditableVmField&lt;/code&gt; annotation was given three fields: &lt;code&gt;onHostedEngine&lt;/code&gt;, &lt;code&gt;hotsetAllowed&lt;/code&gt;, and &lt;code&gt;onStatuses&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The third and final step was to address the way entity statuses were handled, as the previous implementation was problematic. &lt;code&gt;EditableOnVmStatus&lt;/code&gt; and &lt;code&gt;EditableOnVdsStatus&lt;/code&gt; both required each status for which a field is editable to be listed in its &lt;code&gt;onStatus&lt;/code&gt; field. Initially, this makes sense, but consider a field that is editable under any status. The obvious long list of statuses aside, this approach requires that the status list for such a field be updated any time a new status is added to the entity. If the individual adding the status isn't aware of this requirement, a silent regression would be introduced.&lt;/p&gt;

&lt;p&gt;In addition to this potentially serious problem, the implementation of each annotation provided a default list of statuses to be used if no status list was provided in the annotation declaration. In order to be aware of the existence of these default lists, an individual would have to either be familiar with the implementation code or have been informed by a third party.&lt;/p&gt;

&lt;p&gt;In the consolidated version, if no explicit list is provided in the &lt;code&gt;onStatuses&lt;/code&gt; field of the &lt;code&gt;EditableVmField&lt;/code&gt; and &lt;code&gt;EditableVdsField&lt;/code&gt; annotations, it is assumed that the field is editable under all statuses. However, if a list is provided within the annotation declaration, the field will be considered editable only if it is in a status provided in that list. This implementation is clearer, as the &lt;code&gt;onStatuses&lt;/code&gt; field will only be used if the statuses list is being restricted, and the restricted list will be displayed alongside the field to which it applies. It also avoids the entity status update problem.&lt;/p&gt;

&lt;h2 id="the-end-state"&gt;The End State&lt;/h2&gt;

&lt;p&gt;If we employ the new annotations using our previous &lt;code&gt;memSizeMb&lt;/code&gt; example, we get the following:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;@CopyOnNewVersion
@EditableVmField(
        onHostedEngine = true,
        hotsetAllowed = true,
        onStatuses = { VMStatus.Down })
@EditableVmTemplateField
private int memSizeMb;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the line count increased, the conceptual weight of the code has been reduced. The entities for which this field is editable are obvious, and the conditions under which the field is editable for a VM entity are immediately clear.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The line count has only increased due to the styling convention being employed. The same code could be written as:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;@CopyOnNewVersion
@EditableVmField(onHostedEngine = true, hotsetAllowed = true, onStatuses = { VMStatus.Down })
@EditableVmTemplateField
private int memSizeMb;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Overall, we feel that this change will provide a cleaner way of representing this information for both the readers and writers of this code.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Dependency Injection and Mockito</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/07/dependency-injection-and-mockito.html"/>
    <id>http://ovirt.org/blog/2016/07/dependency-injection-and-mockito.html</id>
    <published>2016-07-12T13:15:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Jenny Tokar</name>
    </author>
    <content type="html">&lt;p&gt;Recently I encountered a small issue in a static helper class that was full of static helper methods. After I finished dealing with the issue at hand and as part of following the Boy Scout rule (always leave the campground cleaner than you found it) I decided to refactor the class and the code using it.&lt;/p&gt;

&lt;p&gt;More specifically to remove all the static modifiers and to inject this class whenever it was needed.
The refactoring was easy enough but things got a bit more interesting once I got to a class that was using one of the static helper methods.&lt;/p&gt;

&lt;p&gt;The class had a wrapper method that called the static method and did nothing more.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;    &lt;span class="nd"&gt;@Inject&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;HostedEngineHelper&lt;/span&gt; &lt;span class="n"&gt;hostedEngineHelper&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isHostedEngine&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageDomain&lt;/span&gt; &lt;span class="n"&gt;storageDomain&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hostedEngineHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isHostedEngineStorageDomain&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;storageDomain&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Those kind of wrapper methods are common in code that uses mocking testing frameworks for unit testing. They certainly are very easy to mock. However, code shouldn’t exist for the sake of tests and unnecessary methods that are dirtying it should be removed.&lt;/p&gt;

&lt;h2 id="introducing-injectmocks"&gt;Introducing @InjectMocks&lt;/h2&gt;

&lt;p&gt;And here comes the nice part: Mockito supports injecting mock classes into the tested class in a very neat way.
You simply add the helper class you need with the &lt;strong&gt;“@Mock”&lt;/strong&gt; annotation and put the &lt;strong&gt;“@InjectMocks”&lt;/strong&gt; annotation on the class you are mocking for testing and that’s it.&lt;/p&gt;

&lt;p&gt;Mockito will inject the mocked instance to the mocked class so you won’t fall on null pointer exceptions and you will be able to mock the methods you are not testing directly.&lt;/p&gt;

&lt;p&gt;So instead of having something like this in your test class:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;StorageDomainCommandBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;StorageDomainParametersBase&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;spy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TestStorageCommandBase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StorageDomainParametersBase&lt;/span&gt;&lt;span class="o"&gt;()));&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;shouldElectActiveDataDomain&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;StorageDomain&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;prepareStorageDomainForElection&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageDomainStatus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Active&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"not he domain name"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;doReturn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;isHostedEngine&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageDomain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;electNewMaster&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You end up with something like this:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight java"&gt;&lt;code&gt;    &lt;span class="nd"&gt;@Mock&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;HostedEngineHelper&lt;/span&gt; &lt;span class="n"&gt;hostedEngineHelper&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@InjectMocks&lt;/span&gt;
    &lt;span class="nd"&gt;@Spy&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;StorageDomainCommandBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;StorageDomainParametersBase&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TestStorageCommandBase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StorageDomainParametersBase&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;shouldElectActiveDataDomain&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;StorageDomain&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prepareStorageDomainForElection&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageDomainStatus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Active&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"not he domain name"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;when&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hostedEngineHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isHostedEngineStorageDomain&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StorageDomain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;))).&lt;/span&gt;&lt;span class="na"&gt;thenReturn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;assertEquals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;electNewMaster&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Injecting the helper class instead of using it in a static way allows a much cleaner way for writing clear and concise code that doesn't leave the readers wondering about redundant methods.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>oVirt 4.0 is Released!</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/06/ovirt-40-release.html"/>
    <id>http://ovirt.org/blog/2016/06/ovirt-40-release.html</id>
    <published>2016-06-23T15:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Mikey Ariel</name>
    </author>
    <content type="html">&lt;p&gt;On behalf of the oVirt community, I am pleased to announce a major new release today, oVirt 4.0. This latest community release, now ready for &lt;a href="http://www.ovirt.org/download/"&gt;download&lt;/a&gt;, has several new features, including a brand-new dashboard management and monitoring system; enhanced container support; faster live migration speeds; and a new direct-for-disk image uploader.&lt;/p&gt;

&lt;p&gt;As the upstream development project for Red Hat Enterprise Virtualization, oVirt’s integrated virtualization enables cost savings for enterprises without the need to re-develop applications to conform to cloud platforms' APIs. oVirt also shares services with Red Hat’s cloud solutions including RDO, Red Hat's community OpenStack distribution, as well as stronger container support that integrates tools from Project Atomic, Red Hat's robust container management tool set.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;New features highlighted in this release are:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;New Administration Portal:&lt;/strong&gt; Our UX team has created a stunning new dashboard to monitor and control your datacenter, based on feedback from oVirt users. Administrators can visualize the strength of their datacenters and virtual machines at a glance with the highly visual dashboard in place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Improved Live-Migration Performance:&lt;/strong&gt; Much faster migrations speeds for host-to-host migration with policies that are now completely customizable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Improved Image Features:&lt;/strong&gt; In previous versions of oVirt, VM images needed to be uploaded via command line. With oVirt 4.0, these images can now be selected and uploaded to the oVirt instance right from within the web-based portal. oVirt 4.0 also now enables importing libvirt VMs using the virt-v2v tool.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Container Support:&lt;/strong&gt; Support for Atomic guest OS machines is included, with reports available about containers running in them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;New oVirt Node:&lt;/strong&gt; The just-enough operating system version of oVirt has been revamped and includes a Cockpit-based management system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developer Improvements:&lt;/strong&gt; The new API v4 is cleaner and provided improved performance, and a Ruby SDK is now included in oVirt.&lt;/p&gt;

&lt;p&gt;Other exciting new features in this release of oVirt include the capability to deploy additional hosts for Hosted Engine directly from the Web portal, as well as improvements to Gluster hyper-converged setups, per-interface MAC anti-spoofing, and FiberChannel over Ethernet support via VDSM hook.&lt;/p&gt;

&lt;p&gt;A complete list of oVirt 4.0 features is available in the &lt;a href="http://www.ovirt.org/release/4.0.0/"&gt;oVirt 4.0 Release Notes&lt;/a&gt;. oVirt 4.0  is a big step forward in improving the virtual datacenter management experience, improving what is already available in oVirt with more speed and power than ever, while adding improvements to the platform that will take it to the next level of virtual machine management in an increasingly DevOps-oriented IT environment.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.ovirt.org/download/"&gt;Download the latest version of oVirt&lt;/a&gt; today!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Welcome to the new oVirt.org website!</title>
    <link rel="alternate" href="http://ovirt.org/blog/2016/02/welcome-to-new-ovirt-site.html"/>
    <id>http://ovirt.org/blog/2016/02/welcome-to-new-ovirt-site.html</id>
    <published>2016-02-19T15:00:00+00:00</published>
    <updated>2019-06-16T09:04:04+00:00</updated>
    <author>
      <name>Mikey Ariel</name>
    </author>
    <content type="html">&lt;p&gt;As part of our efforts to upgrade the ovirt.org website and improve the community experience, we migrated the oVirt website from a MediaWiki site to a static site, authored in &lt;a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/"&gt;Markdown&lt;/a&gt; and published with &lt;a href="https://middlemanapp.com/"&gt;Middleman&lt;/a&gt;. This was a major project that took more than 6 months and involved many contributors from all aspects of the project.&lt;/p&gt;

&lt;p&gt;I'd like to take this opportunity to thank all the people who were involved with this migration, from content reviewers to UX designers and Website admins who gave their time and brain power to make this happen.&lt;/p&gt;

&lt;p&gt;The old MediaWiki site is &lt;a href="http://old.ovirt.org/Home"&gt;still available in read-only&lt;/a&gt;, and will be taken offline once we fix some pending issues, including handling PDF files and such.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="whats-new"&gt;What's new?&lt;/h2&gt;

&lt;p&gt;The new Website is full of improvements and enhancements, check out these highlights:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Source content is now formatted in Markdown instead of MediaWiki. This means that you can create and edit documentation, blog posts, and feature pages with the same Markdown syntax you know.&lt;/li&gt;
  &lt;li&gt;The Website is deployed with Middleman and stored on GitHub. This means that you can make changes to content with the same GitHub contribution workflow that you know (fork, clone, edit, commit, submit pull request). We even have an "Edit this page on GitHub" link at the bottom of every page!&lt;/li&gt;
  &lt;li&gt;New layout and design, from breadcrumbs to sidebards and an upgraded landing page.&lt;/li&gt;
  &lt;li&gt;Automatic redirects from the old MediaWiki site. This means that if the wiki page exists in the new website, previously-released URLs will redirect to that page. If the page was removed, the Search page will open with the page title auto-filled in the search box.&lt;/li&gt;
  &lt;li&gt;Hierarchical content structure. This means that instead of flat Wiki-style files, the deployed Website reflects an organized source repo with content sorted into directories and sub-directories.&lt;/li&gt;
  &lt;li&gt;Official oVirt blog! This first post marks the beginning of our new blog, and we welcome contributions. This means that if you solved a problem with oVirt, want to share your oVirt story, or describe a cool integration, you can submit a blog post and we will provide editorial reviews and help publish your posts.&lt;/li&gt;
  &lt;li&gt;Standardized contribution process. The GitHub repo now includes a &lt;a href="https://github.com/oVirt/ovirt-site/blob/master/README.md"&gt;README.md&lt;/a&gt; file that you can use to learn about how to add and edit content on the website. We welcome pull requests!&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="known-issues"&gt;Known Issues&lt;/h1&gt;

&lt;p&gt;Despite our best efforts, there are still a few kinks with the new website that you should be aware of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Attempting to navigate to ovirt.org (without www.) leads to a redirect loop. We have a ticket open with OpenShift, our hosting service to fix this.&lt;/li&gt;
  &lt;li&gt;Only http is available. We also have a ticket with OpenShift to add SSL and enable https.&lt;/li&gt;
  &lt;li&gt;Home page and Download page are still being upgraded by our UX team, expect some cool new changes soon!&lt;/li&gt;
  &lt;li&gt;Feature pages look-and-feel is still under construction. You can still edit and push feature pages as usual.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="whats-next"&gt;What's Next&lt;/h1&gt;

&lt;p&gt;Even though the Website is live, the work is hardly over. We'd like to ask for your help in:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reviewing content for anything obsolete or outdated; each page in the new website includes a header toolbar with metadata from the original wiki page for your convenience&lt;/li&gt;
  &lt;li&gt;Submitting blog posts or any other content that you wish to share with the oVirt community&lt;/li&gt;
  &lt;li&gt;Reporting bugs and proposing enhancements, for example broken links or missing pages&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We hope you will enjoy the new oVirt Website, looking forward to your feedback and contributions!&lt;/p&gt;
</content>
  </entry>
</feed>
